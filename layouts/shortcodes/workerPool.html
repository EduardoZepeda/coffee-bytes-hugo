<!-- Worker Pool Design Pattern Shortcode -->
<div id="worker-pool-{{ .Page.File.UniqueID | default "default" }}"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

<style>
    .worker-pool-container {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 80vh;
        border-radius: 12px;
        overflow: hidden;
    }
    
    .worker-pool-container .container {
        display: flex;
        height: 80vh;
        gap: 2px;
    }
    
    .worker-pool-container .panel {
        flex: 1;
        padding: 20px;
        overflow-y: auto;
        position: relative;
    }
    
    .worker-pool-container .left-panel {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
    }
    
    .worker-pool-container .right-panel {
        background: rgba(0, 0, 0, 0.85);
        color: white;
    }
    
    .worker-pool-container .controls {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        backdrop-filter: blur(5px);
    }
    
    .worker-pool-container .control-group {
        margin-bottom: 15px;
    }
    
    .worker-pool-container .control-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: #333;
    }
    
    .worker-pool-container .right-panel .control-group label {
        color: white;
    }
    
    .worker-pool-container input[type="range"] {
        width: 100%;
        margin-bottom: 5px;
    }
    
    .worker-pool-container button {
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        margin-right: 10px;
        margin-bottom: 10px;
        transition: transform 0.2s;
    }
    
    .worker-pool-container button:hover {
        transform: translateY(-2px);
    }
    
    .worker-pool-container button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }
    
    .worker-pool-container .visualization {
        background: white;
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    .worker-pool-container .worker-pool {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        margin-bottom: 30px;
    }
    
    .worker-pool-container .worker {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: white;
        transition: all 0.3s ease;
        position: relative;
        cursor: pointer;
    }
    
    .worker-pool-container .worker.idle {
        background: linear-gradient(45deg, #4ade80, #22c55e);
        animation: pulse-idle 2s infinite;
    }
    
    .worker-pool-container .worker.busy {
        background: linear-gradient(45deg, #f59e0b, #d97706);
        animation: spin 1s linear infinite;
    }
    
    .worker-pool-container .worker.error {
        background: linear-gradient(45deg, #ef4444, #dc2626);
        animation: shake 0.5s ease-in-out;
    }
    
    @keyframes pulse-idle {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.02); }
    }
    
    @keyframes spin {
        0% { transform: translate(0, 0) rotate(0deg); }
        25% { transform: translate(5px, 5px) rotate(5deg); }
        50% { transform: translate(0, 0) rotate(0eg); }
        75% { transform: translate(-5px, 5px) rotate(-5deg); }
        100% { transform: translate(0, 0) rotate(0deg); }
    }
    
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
    }
    
    .worker-pool-container .task-queue {
        background: #f8fafc;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    .worker-pool-container .queue-header {
        font-weight: 600;
        margin-bottom: 10px;
        color: #374151;
    }
    
    .worker-pool-container .queue-items {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
    }
    
    .worker-pool-container .task-item {
        background: linear-gradient(45deg, #3b82f6, #1d4ed8);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
        from { transform: translateX(-20px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    
    .worker-pool-container .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px;
        margin-top: 20px;
    }
    
    .worker-pool-container .stat-card {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 8px;
        text-align: center;
        backdrop-filter: blur(5px);
    }
    
    .worker-pool-container .stat-value {
        font-size: 24px;
        font-weight: bold;
        display: block;
    }
    
    .worker-pool-container .stat-label {
        font-size: 12px;
        opacity: 0.8;
    }
    
    .worker-pool-container .code-section {
        background: #1e293b;
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
        overflow-x: auto;
    }
    
    .worker-pool-container .code-section pre {
        margin: 0;
        color: #e2e8f0;
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 14px;
        line-height: 1.5;
    }
    
    .worker-pool-container .keyword { color: #f59e0b; }
    .worker-pool-container .string { color: #10b981; }
    .worker-pool-container .comment { color: #6b7280; }
    .worker-pool-container .function { color: #3b82f6; }
    
    .worker-pool-container .section-spacing {
        margin-top: 30px;
    }
    
    .worker-pool-container .header-spacing {
        margin: 0 0 20px 0;
    }
    
    .worker-pool-container .task-tooltip {
        position: absolute;
        top: -25px;
        font-size: 10px;
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        white-space: nowrap;
    }
</style>

<script>
    (function() {
        const { useState, useEffect, useRef, createElement: e } = React;
        
        const WorkerPoolVisualization = () => {
            const [workers, setWorkers] = useState([]);
            const [taskQueue, setTaskQueue] = useState([]);
            const [isRunning, setIsRunning] = useState(false);
            const [workerCount, setWorkerCount] = useState(4);
            const [taskInterval, setTaskInterval] = useState(1000);
            const [processTime, setProcessTime] = useState(2000);
            const [stats, setStats] = useState({
                totalTasks: 0,
                completedTasks: 0,
                failedTasks: 0,
                queueSize: 0
            });
            
            const intervalRef = useRef();
            const taskIdRef = useRef(0);
            
            // Initialize workers
            useEffect(() => {
                const newWorkers = Array.from({ length: workerCount }, (_, i) => ({
                    id: i + 1,
                    status: 'idle',
                    currentTask: null,
                    completedTasks: 0
                }));
                setWorkers(newWorkers);
            }, [workerCount]);
            
            // Task generation
            useEffect(() => {
                if (isRunning) {
                    intervalRef.current = setInterval(() => {
                        const newTask = {
                            id: ++taskIdRef.current,
                            name: `Task ${taskIdRef.current}`,
                            createdAt: Date.now()
                        };
                        
                        setTaskQueue(prev => [...prev, newTask]);
                        setStats(prev => ({ 
                            ...prev, 
                            totalTasks: prev.totalTasks + 1,
                            queueSize: prev.queueSize + 1
                        }));
                    }, taskInterval);
                }
                
                return () => clearInterval(intervalRef.current);
            }, [isRunning, taskInterval]);
            
            // Process tasks
            useEffect(() => {
                const processNextTask = () => {
                    setWorkers(currentWorkers => {
                        const newWorkers = [...currentWorkers];
                        let newQueue = [...taskQueue];
                        
                        const idleWorkers = newWorkers.filter(w => w.status === 'idle');
                        const tasksToProcess = Math.min(idleWorkers.length, newQueue.length);
                        
                        for (let i = 0; i < tasksToProcess; i++) {
                            const worker = idleWorkers[i];
                            const task = newQueue.shift();
                            
                            worker.status = 'busy';
                            worker.currentTask = task;
                            
                            setTimeout(() => {
                                setWorkers(workers => {
                                    const updatedWorkers = workers.map(w => {
                                        if (w.id === worker.id) {
                                            const success = Math.random() > 0.1;
                                            return {
                                                ...w,
                                                status: success ? 'idle' : 'error',
                                                currentTask: null,
                                                completedTasks: success ? w.completedTasks + 1 : w.completedTasks
                                            };
                                        }
                                        return w;
                                    });
                                    return updatedWorkers;
                                });
                                
                                setStats(prevStats => ({
                                    ...prevStats,
                                    completedTasks: prevStats.completedTasks + 1,
                                    queueSize: Math.max(0, prevStats.queueSize - 1)
                                }));
                                
                                setTimeout(() => {
                                    setWorkers(workers => 
                                        workers.map(w => 
                                            w.id === worker.id && w.status === 'error' 
                                                ? { ...w, status: 'idle' } 
                                                : w
                                        )
                                    );
                                }, 1000);
                            }, processTime + Math.random() * 1000);
                        }
                        
                        setTaskQueue(newQueue);
                        setStats(prev => ({
                            ...prev,
                            queueSize: newQueue.length
                        }));
                        
                        return newWorkers;
                    });
                };
                
                if (taskQueue.length > 0) {
                    processNextTask();
                }
            }, [taskQueue, processTime]);
            
            const toggleSimulation = () => setIsRunning(!isRunning);
            
            const resetSimulation = () => {
                setIsRunning(false);
                setTaskQueue([]);
                setStats({
                    totalTasks: 0,
                    completedTasks: 0,
                    failedTasks: 0,
                    queueSize: 0
                });
                taskIdRef.current = 0;
            };
            
            const addManualTask = () => {
                const newTask = {
                    id: ++taskIdRef.current,
                    name: `Manual Task ${taskIdRef.current}`,
                    createdAt: Date.now()
                };
                setTaskQueue(prev => [...prev, newTask]);
                setStats(prev => ({ 
                    ...prev, 
                    totalTasks: prev.totalTasks + 1,
                    queueSize: prev.queueSize + 1
                }));
            };
            
            return e('div', { className: 'worker-pool-container' },
                e('div', { className: 'container' },
                    // Left Panel
                    e('div', { className: 'panel left-panel' },
                        e('div', { className: 'controls' },
                            e('h2', { className: 'header-spacing', style: { color: '#1f2937' } }, 'Worker Pool Controls'),
                            
                            e('div', { className: 'control-group' },
                                e('label', null, `Workers: ${workerCount}`),
                                e('input', {
                                    type: 'range',
                                    min: '1',
                                    max: '8',
                                    value: workerCount,
                                    onChange: (ev) => setWorkerCount(parseInt(ev.target.value)),
                                    disabled: isRunning
                                })
                            ),
                            
                            e('div', { className: 'control-group' },
                                e('label', null, `Task Interval: ${taskInterval}ms`),
                                e('input', {
                                    type: 'range',
                                    min: '500',
                                    max: '3000',
                                    step: '100',
                                    value: taskInterval,
                                    onChange: (ev) => setTaskInterval(parseInt(ev.target.value))
                                })
                            ),
                            
                            e('div', { className: 'control-group' },
                                e('label', null, `Process Time: ${processTime}ms`),
                                e('input', {
                                    type: 'range',
                                    min: '1000',
                                    max: '5000',
                                    step: '100',
                                    value: processTime,
                                    onChange: (ev) => setProcessTime(parseInt(ev.target.value))
                                })
                            ),
                            
                            e('div', null,
                                e('button', { onClick: toggleSimulation }, isRunning ? 'Stop' : 'Start', ' Auto Tasks'),
                                e('button', { onClick: addManualTask }, 'Add Task'),
                                e('button', { onClick: resetSimulation }, 'Reset')
                            )
                        ),
                        
                        e('div', { className: 'visualization' },
                            e('h3', { className: 'header-spacing', style: { color: '#1f2937' } }, 'Worker Pool'),
                            e('div', { className: 'worker-pool' },
                                ...workers.map(worker => 
                                    e('div', {
                                        key: worker.id,
                                        className: `worker ${worker.status}`
                                    },
                                    `W${worker.id}`,
                                    worker.currentTask && e('div', {
                                        className: 'task-tooltip'
                                    }, worker.currentTask.name)
                                    )
                                )
                            ),
                            
                            e('div', { className: 'task-queue' },
                                e('div', { className: 'queue-header' }, `Task Queue (${taskQueue.length} items)`),
                                e('div', { className: 'queue-items' },
                                    ...taskQueue.slice(0, 10).map(task =>
                                        e('div', { key: task.id, className: 'task-item' }, task.name)
                                    ),
                                    taskQueue.length > 10 && e('div', {
                                        className: 'task-item',
                                        style: { background: '#6b7280' }
                                    }, `+${taskQueue.length - 10} more`)
                                )
                            )
                        )
                    ),
                    
                    // Right Panel
                    e('div', { className: 'panel right-panel' },
                        e('h2', { className: 'header-spacing' }, 'Worker Pool Pattern'),
                        
                        e('div', { className: 'stats' },
                            e('div', { className: 'stat-card' },
                                e('span', { className: 'stat-value' }, stats.totalTasks),
                                e('span', { className: 'stat-label' }, 'Total Tasks')
                            ),
                            e('div', { className: 'stat-card' },
                                e('span', { className: 'stat-value' }, stats.completedTasks),
                                e('span', { className: 'stat-label' }, 'Completed')
                            ),
                            e('div', { className: 'stat-card' },
                                e('span', { className: 'stat-value' }, stats.queueSize),
                                e('span', { className: 'stat-label' }, 'In Queue')
                            ),
                            e('div', { className: 'stat-card' },
                                e('span', { className: 'stat-value' }, workers.filter(w => w.status === 'busy').length),
                                e('span', { className: 'stat-label' }, 'Active Workers')
                            )
                        ),
                        
                        e('div', { className: 'section-spacing' },
                            e('h3', null, 'How it Works'),
                            e('p', null, 'The Worker Pool pattern manages a fixed number of worker threads to process tasks concurrently:'),
                            e('ul', null,
                                e('li', null, e('strong', null, 'Green workers'), ' are idle and ready for tasks'),
                                e('li', null, e('strong', null, 'Orange workers'), ' are busy processing tasks'),
                                e('li', null, e('strong', null, 'Red workers'), ' encountered an error (10% chance)'),
                                e('li', null, 'Tasks wait in queue until a worker becomes available'),
                                e('li', null, 'Pool size limits resource usage and prevents system overload')
                            )
                        ),
                        
                        e('div', { className: 'code-section' },
                            e('pre', null)
                        )
                    )
                )
            );
        };
        
        const containerId = 'worker-pool-{{ .Page.File.UniqueID | default "default" }}';
        const container = document.getElementById(containerId);
        if (container) {
            ReactDOM.render(React.createElement(WorkerPoolVisualization), container);
        }
    })();
</script>